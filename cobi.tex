\documentclass[aspectratio=169]{beamer}
% \usetheme{Madrid}
\usecolortheme{default}

\usepackage{amsmath}
\usepackage{tikz}
\usetikzlibrary{shapes,arrows,positioning,fit,calc}
\usepackage{graphicx}
\usepackage{physics}
\usepackage{booktabs}
\usepackage{subcaption}
\usepackage{pgfplots}
\usepackage{svg}

\newcommand\Wider[2][3em]{%
\makebox[\linewidth][c]{%
  \begin{minipage}{\dimexpr\textwidth+#1\relax}
  \raggedright#2
  \end{minipage}%
  }%
}


  \def\mathdefault#1{#1}
  \everymath=\expandafter{\the\everymath\displaystyle}
  \makeatletter\@ifpackageloaded{underscore}{}{\usepackage[strings]{underscore}}\makeatother

\title{Topological Analysis of Decision Boundaries}
\author{Maxim Mikhaylov with supervision by Dr. Patrick Schnider}
\institute{ETH ZÃ¼rich}
\date{\small Sep 2024 -- Feb 2025}

\newcommand{\todo}[1]{\textcolor{red}{TODO: #1}}

\begin{document}

\begin{frame}
    \titlepage
\end{frame}

\begin{frame}{Profile}
    \begin{columns}
        \column{0.5\textwidth}
        Engineering
        \begin{itemize}
            \item \textbf{Core:} computational methods, including numerical implementation (C++)
            \item \textbf{Skills:}
            \begin{itemize}
                \item Systems programming
                \item Optimization
                \item Parallel programming
                \item Numerical methods
            \end{itemize} 
        \end{itemize}
        I build fast, reliable software for computationally intensive research tasks.
        \column{0.5\textwidth}
        Research
        \begin{itemize}
            \item \textbf{Focus:} physical systems and interdisciplinary problems
            \item \textbf{Experience:} \begin{itemize}
                \item Robotics (ITMO)
                \item Satellite Nav (Bosch)
                \item Topological Data Analysis (ETH)
            \end{itemize}
        \end{itemize}
        I research physical reality with computational methods.
    \end{columns}
\end{frame}

\begin{frame}{Project Introduction}
    \begin{itemize}
        \item Neural networks partition high-dimensional input spaces into class regions.
        \item The boundaries between these regions, \emph{decision boundaries}, are important for generalization.
        \item Hypothesis: The topological complexity (e.g., fragmentation, holes) of these surfaces correlates with overfitting.
    \end{itemize}
    \begin{figure}
\begin{tikzpicture}[scale=0.8, transform shape]
        % 1. Define Styles (Consistent with previous slides)
        \tikzset{
            bluept/.style={circle, fill=blue!90, draw=black, thick, inner sep=2.5pt},
            redpt/.style={circle, fill=red!90, draw=black, thick, inner sep=2.5pt},
            boundary/.style={draw=black, ultra thick, smooth},
            regionBlue/.style={fill=blue!10},
            regionRed/.style={fill=red!10},
            annotation/.style={
                draw=gray!80, fill=white, rounded corners, 
                font=\small\sffamily, align=center
            },
            arrow/.style={->, >=stealth, thick, gray!80}
        }

        % Clip the view
        % \clip[rounded corners] (-0.5, -0.5) rectangle (8.5, 6);
        \draw[gray!50] (-0.5, -0.5) rectangle (8.5, 6);

        % --- 2. DRAW REGIONS ---
        % We define a path for the boundary: A "Wiggle" (Sine wave-ish)
        % Start high left, dip down, go up, dip down right.
        \def\boundaryPath{
            (-0.5, 4.5) .. controls (2, 1) and (4, 5) .. (6, 2) .. controls (7, 0.5) .. (8.5, 1)
        }

        % Fill Red Region (Below line)
        \fill[regionRed] \boundaryPath -- (8.5, -0.5) -- (-0.5, -0.5) -- (-0.5, 6) -- cycle;

        % Fill Blue Region (Above line)
        \fill[regionBlue] \boundaryPath -- (8.5, 6) -- (-0.5, 6) -- cycle;

        % --- 3. DRAW THE BOUNDARY ---
        \draw[boundary] \boundaryPath;

        % --- 4. DATA POINTS (Fitting the wiggle) ---
        
        % Red Points (Below the wiggle)
        \node[redpt] at (1.0, 1.5) {};
        \node[redpt] at (2.0, 1.0) {};
        \node[redpt] at (0.5, 2.5) {};
        \node[redpt] at (3.0, 2.0) {};
        \node[redpt] at (5.5, 1.0) {};
        \node[redpt] at (7.0, 0.5) {};
        \node[redpt] at (8.0, 0.2) {};
        \node[redpt] (targetRed) at (4.5, 1.8) {}; % Target for annotation

        % Blue Points (Above the wiggle)
        \node[bluept] at (1.0, 4.5) {};
        \node[bluept] at (2.5, 4.0) {};
        \node[bluept] (targetBlue) at (3.5, 4.8) {}; % Target for annotation
        \node[bluept] at (5.0, 4.0) {};
        \node[bluept] at (6.5, 3.5) {};
        \node[bluept] at (7.5, 2.5) {};
        \node[bluept] at (8.0, 4.0) {};

        % --- 5. ANNOTATIONS (The Educational Part) ---

        % A. The Points
        \node[annotation] (notePoint) at (-2.5, 3.5) {\textbf{Data points}\\Labeled inputs};
        \draw[arrow] (notePoint) -- (targetBlue);
        
        % B. The Boundary
        \node[annotation] (noteBoundary) at (11.0, 3.2) {\textbf{Decision boundary}\\The surface separating\\class regions};
        \draw[arrow] (noteBoundary) -- (5.3, 2.85); % Pointing to the line middle

        % C. The Regions
        % \node[annotation] (noteRegion) at (2.0, 0.2) {\textbf{Decision Region}\\Predicted Class: Red};
        % No arrow needed, it sits inside the region

        % Add math label for regions
        \node[blue!60!black, font=\bfseries] at (6.5, 5.0) {Class 1};
        \node[red!60!black, font=\bfseries] at (1.5, 0.2) {Class 0};

    \end{tikzpicture}
    \end{figure}
\end{frame}

\begin{frame}{Theoretical background: Overfitting}
    % \begin{columns}
    %     \column{0.7\textwidth}
        \begin{itemize}
            \item Model fits training data too closely, fails to generalize to unseen data
            \item Performance improves on training data, but degrades on validation data
            \item Maybe this is reflected in the topology of decision boundaries?
        \end{itemize}
    %     \column{0.3\textwidth}
    %     \begin{figure}
    %         \textcolor{red}{Illustration of overfitting here; plot of training acc improving, validation acc dropping.}
    %     \end{figure}
    % \end{columns}
    \begin{figure}
    \begin{tikzpicture}[scale=0.7, transform shape]
        % 1. Define Styles: High contrast, saturated points
        \tikzset{
            bluept/.style={circle, fill=blue!90, draw=black, thick, inner sep=2pt},
            redpt/.style={circle, fill=red!90, draw=black, thick, inner sep=2pt},
            boundary/.style={draw=black, very thick},
            regionBlue/.style={fill=blue!15},
            regionRed/.style={fill=red!15}
        }

        % 2. Define Data Points: "Red Island" surrounded by "Blue Ocean"
        \newcommand{\datapoints}{
            % --- RED CLUSTER (Center) ---
            \node[redpt] at (1.8, 1.8) {};
            \node[redpt] at (2.2, 2.2) {};
            \node[redpt] at (1.7, 2.3) {};
            \node[redpt] at (2.3, 1.7) {};
            \node[redpt] at (2.0, 2.4) {};

            % --- BLUE RING (Surrounding) ---
            % Corners
            \node[bluept] at (0.6, 0.6) {};
            \node[bluept] at (0.6, 3.4) {};
            \node[bluept] at (3.4, 3.4) {};
            \node[bluept] at (3.4, 0.6) {};
            % Edges
            \node[bluept] at (2.0, 0.4) {};
            \node[bluept] at (2.0, 3.6) {};
            \node[bluept] at (0.4, 2.0) {};
            \node[bluept] at (3.6, 2.0) {};

            % --- NOISE POINTS ---
            % Blue Noise inside Red Cluster (The Hole)
            \node[bluept] at (2.0, 2.0) {}; 
            
            % Red Noise inside Blue Ring (The Satellite)
            \node[redpt] at (3.1, 3.1) {};
        }

        % --- PLOT 1: Underfitting (Linear) ---
        % A line cannot separate an island from the ocean.
        \begin{scope}[xshift=0cm]
            % \clip[rounded corners] (-0.5, -0.5) rectangle (4, 4);
            
            % Background (Blue)
            \fill[regionBlue] (-0.5, -0.5) rectangle (4, 4);
            
            % Red Region (Linear Cut - Fails)
            \fill[regionRed] (1, 4) -- (4, 1) -- (4, 4) -- cycle;
            \draw[boundary, color=green!40!black] (1, 4) -- (4, 1);
            
            \draw[gray!50] (-0.5, -0.5) rectangle (4, 4);
            \node[font=\small] at (1.75, -0.8) {Underfit};
            
            \datapoints
        \end{scope}

        % --- PLOT 2: Generalization (Smooth Topology) ---
        % A simple circle captures the main cluster.
        \begin{scope}[xshift=5.5cm]
            % \clip[rounded corners] (-0.5, -0.5) rectangle (4, 4);

            % Background (Blue)
            \fill[regionBlue] (-0.5, -0.5) rectangle (4, 4);
            
            % Red Region (Smooth Circle)
            \fill[regionRed] (2.0, 2.0) circle (1.1);
            \draw[boundary, color=green!40!black] (2.0, 2.0) circle (1.1);
            
            \draw[gray!50] (-0.5, -0.5) rectangle (4, 4);
            \node[font=\small] at (1.75, -0.8) {Fit};
            
            \datapoints
        \end{scope}

        % --- PLOT 3: Overfitting (Complex Topology) ---
        % Holes and Islands appear.
        \begin{scope}[xshift=11cm]
            % \clip[rounded corners] (-0.5, -0.5) rectangle (4, 4);

            % Background (Blue)
            \fill[regionBlue] (-0.5, -0.5) rectangle (4, 4);
            
            % 1. Main Red Blob (Distorted Circle)
            \fill[regionRed] (2.0, 2.0) circle (1.1);
            \draw[boundary, color=green!40!black] (2.0, 2.0) circle (1.1);

            % 2. The Topological Change (Hole for Blue Noise)
            \fill[regionBlue] (2.0, 2.0) circle (0.25);
            \draw[boundary, color=green!40!black] (2.0, 2.0) circle (0.25);
            
            % 3. The Topological Change (Island for Red Noise)
            \fill[regionRed] (3.1, 3.1) circle (0.25);
            \draw[boundary, color=green!40!black] (3.1, 3.1) circle (0.25);

            \draw[gray!50] (-0.5, -0.5) rectangle (4, 4);
            \node[font=\small] at (1.75, -0.8) {Overfit};
            
            \datapoints
        \end{scope}

    \end{tikzpicture}
    \end{figure}
\end{frame}



\begin{frame}{Theoretical background: Persistent homology}
    \begin{itemize}
        \only<1>{\vspace*{10pt}}
        \only<4-5>{\vspace*{10pt}}
        \item<1-> Simplicial complex: a collection of simplices glued together ``nicely''
        \only<1>{
            \includegraphics[width=0.6\textwidth]{simplicial_complex.png}
        }

        \item<2-> Homology groups of dimension $p$: measure the number of $p$-dimensional holes in a simplicial complex
        \begin{itemize}
            \item<3-> $p = 0$: connected components
            \item<4-> $p = 1$: unfilled cycles
            
            \only<4>{\includegraphics[width=0.4\textwidth]{h1.png}}

            \item<5-> $p = 2$: unfilled voids

            \only<5>{\includegraphics[width=0.3\textwidth]{sphere.png}}
        \end{itemize}
        \item<6-> \emph{Persistent} homology: homology groups of a simplicial complex as it evolves
        \item<7-> Example: growing balls
        
        \includegraphics[width=0.9\textwidth]{persistence.png}
    \end{itemize}
\end{frame}

\begin{frame}{Pipeline to capture decision boundary topology}
    \resizebox{\textwidth}{!}{
    \begin{tikzpicture}[
        node distance=1cm,
        box/.style={rectangle,draw},
        arrow/.style={->,>=stealth,thick},
        every text node part/.style={font=\footnotesize}
    ]

    % First column - Prediction pipeline
    \node[box] (data1) {
        \begin{tikzpicture}
            \foreach \x/\y in {0/0.2, 0.3/0.8, 0.6/0.4, 0.8/0.9, 0.2/0.5, 0.9/0.3} {
                \fill (\x,\y) circle (0.1);
            }
            \draw[->] (0,0) -- (1,0) node[right] {x};
            \draw[->] (0,0) -- (0,1) node[above] {y};
        \end{tikzpicture}
    };

    \node[above=0.1cm of data1] {Input data};

    \node[box,right=of data1] (nn) {
        \begin{tikzpicture}[scale=0.25]
            \foreach \x in {0,...,3} {
                \foreach \y in {0,...,2} {
                    \fill (\x*2,\y*1.5) circle (0.2);
                }
            }
            \foreach \x in {0,...,2} {
                \foreach \y in {0,...,2} {
                    \foreach \z in {0,...,2} {
                        \draw[gray,thin] (\x*2,\y*1.5) -- (\x*2+2,\z*1.5);
                    }
                }
            }
        \end{tikzpicture}
    };

    \node[above=0.1cm of nn] {Neural network};

    \node[box,right=of nn] (pred) {
        \begin{tikzpicture}[]
            \foreach \x/\y/\c in {0/0.2/red, 0.3/0.8/blue, 0.6/0.4/red, 0.8/0.9/blue, 0.2/0.5/red, 0.9/0.3/blue} {
                \fill[\c] (\x,\y) circle (0.1);
            }
            \draw[->] (0,0) -- (1,0);
            \draw[->] (0,0) -- (0,1);
        \end{tikzpicture}
    };

    \node[above=0.1cm of pred, text width=2cm, align=center] {Predicted labels};

    \node[box,right=of pred] (comppred) {
        \begin{tikzpicture}[]
            \fill[gray] (0.2,0.5) -- (0.3,0.8) -- (0.6,0.4) -- cycle;
            \fill[gray] (0.3,0.8) -- (0.8,0.9) -- (0.6,0.4) -- cycle;
            \draw[black,line width=0.3mm] (0.3,0.8) -- (0.8,0.9);
            \draw[black,line width=0.3mm] (0.6,0.4) -- (0.8,0.9);
            \draw[black,line width=0.3mm] (0.6,0.4) -- (0.3,0.8);
            \draw[black,line width=0.3mm] (0.6,0.4) -- (0.9,0.3);
            \draw[black,line width=0.3mm] (0.2,0.5) -- (0.6,0.4);
            \draw[black,line width=0.3mm] (0.2,0.5) -- (0.3,0.8);
            \foreach \x/\y/\c in {0/0.2/red, 0.3/0.8/blue, 0.6/0.4/red, 0.8/0.9/blue, 0.2/0.5/red, 0.9/0.3/blue} {
                \fill[\c] (\x,\y) circle (0.1);
            }
            \draw[->] (0,0) -- (1,0);
            \draw[->] (0,0) -- (0,1);
        \end{tikzpicture}
    };

    \node[above=0.1cm of comppred, text width=2cm, align=center] {Simplicial complex};

    \node[box,right=of comppred] (pd1) {
        \begin{tikzpicture}[]
            \draw[->] (0,0) -- (1,0) node[right] {birth};
            \draw[->] (0,0) -- (0,1) node[above] {death};
            \draw[dashed] (0,0) -- (1,1);
            \foreach \x/\y in {0.2/0.6, 0.4/0.8, 0.3/0.5} {
                \fill (\x,\y) circle (0.1);
            }
        \end{tikzpicture}
    };
    
    \node[above=0.1cm of pd1, text width=2cm, align=center] {Persistence diagram, $\dim = 1$};

    % Second column - Ground truth pipeline
    \node[box,below=1cm of pd1] (pd2) {
        \begin{tikzpicture}[]
            \draw[->] (0,0) -- (1,0) node[right] {birth};
            \draw[->] (0,0) -- (0,1) node[above] {death};
            \draw[dashed] (0,0) -- (1,1);
            \foreach \x/\y in {0.15/0.65, 0.45/0.85, 0.25/0.55} {
                \fill (\x,\y) circle (0.1);
            }
        \end{tikzpicture}
    };

    \node[box,left=1cm of pd2] (compgt) {
        \begin{tikzpicture}[]
            \fill[gray] (0.6,0.4) -- (0.8,0.9) -- (0.9,0.3) -- cycle;
            \fill[gray] (0.3,0.8) -- (0.8,0.9) -- (0.6,0.4) -- cycle;
            \draw[black,line width=0.3mm] (0.8,0.9) -- (0.9,0.3);
            \draw[black,line width=0.3mm] (0.6,0.4) -- (0.9,0.3);
            \draw[black,line width=0.3mm] (0.6,0.4) -- (0.8,0.9);
            \draw[black,line width=0.3mm] (0.3,0.8) -- (0.8,0.9);
            \draw[black,line width=0.3mm] (0.3,0.8) -- (0.6,0.4);
            \foreach \x/\y/\c in {0/0.2/red, 0.3/0.8/red, 0.6/0.4/red, 0.8/0.9/blue, 0.2/0.5/red, 0.9/0.3/blue} {
                \fill[\c] (\x,\y) circle (0.1);
            }
            \draw[->] (0,0) -- (1,0);
            \draw[->] (0,0) -- (0,1);
        \end{tikzpicture}
    };

    \node[below=0.1cm of compgt, text width=2cm, align=center] {Simplicial complex};

    \node[box,left=of compgt] (gt) {
        \begin{tikzpicture}[]
            \foreach \x/\y/\c in {0/0.2/red, 0.3/0.8/red, 0.6/0.4/red, 0.8/0.9/blue, 0.2/0.5/red, 0.9/0.3/blue} {
                \fill[\c] (\x,\y) circle (0.1);
            }
            \draw[->] (0,0) -- (1,0);
            \draw[->] (0,0) -- (0,1);
        \end{tikzpicture}
    };

    \node[below=0.1cm of gt, text width=2.5cm, align=center] {Ground truth labels};

    % Distance calculation
    \node[box,right=of pd1] (dist) {
        \begin{tikzpicture}[]
            \draw[->] (0,0) -- (1,0) node[right] {birth};
            \draw[->] (0,0) -- (0,1) node[above] {death};
            \draw[dashed] (0,0) -- (1,1);
            \foreach \x/\y in {0.2/0.6, 0.4/0.8, 0.3/0.5} {
                \fill[blue] (\x,\y) circle (0.1);
            }
            \foreach \x/\y in {0.15/0.65, 0.45/0.85, 0.25/0.55} {
                \fill[red] (\x,\y) circle (0.1);
            }
            \foreach \x/\y/\xx/\yy in {0.2/0.6/0.15/0.65, 0.4/0.8/0.45/0.85, 0.3/0.5/0.25/0.55} {
                \draw[gray,dotted] (\x,\y) -- (\xx,\yy);
            }
        \end{tikzpicture}
    };

    \node[above=0.1cm of dist] {Wasserstein distance};

    % Arrows
    \draw[arrow] (data1) -- (nn);
    \draw[arrow] (nn) -- (pred);
    \draw[arrow] (pred) -- (comppred);
    \draw[arrow] (comppred) -- (pd1);
    \draw[arrow] (gt) -- (compgt);
    \draw[arrow] (compgt) -- (pd2);
    \draw[arrow] (pd1) -- (dist);
    \draw[arrow] (pd2) -- (dist);

    \end{tikzpicture}
    }
\end{frame}

\begin{frame}{Pipeline}
    \resizebox{\textwidth}{!}{
    \begin{tikzpicture}[
        node distance=1cm,
        box/.style={rectangle,draw},
        arrow/.style={->,>=stealth,thick},
        every text node part/.style={font=\footnotesize}
    ]
    % First column - Prediction pipeline
    \node[box,name=data1] (data1) {
        \begin{tikzpicture}
            \foreach \x/\y in {0/0.2, 0.3/0.8, 0.6/0.4, 0.8/0.9, 0.2/0.5, 0.9/0.3} {
                \fill (\x,\y) circle (0.1);
            }
            \draw[->] (0,0) -- (1,0) node[right] {x};
            \draw[->] (0,0) -- (0,1) node[above] {y};
        \end{tikzpicture}
    };

    \node[above=0.1cm of data1] {Input data};

    \tikzset{
        every node/.style={
            opacity=0.4,
            execute at begin node={\ifx\tikz@fig@name\highlightednode\else\color{black!70}\fi}
        },
        every path/.style={opacity=0.4},
    }

    \node[box,right=of data1] (nn) {
        \begin{tikzpicture}[scale=0.25]
            \foreach \x in {0,...,3} {
                \foreach \y in {0,...,2} {
                    \fill (\x*2,\y*1.5) circle (0.2);
                }
            }
            \foreach \x in {0,...,2} {
                \foreach \y in {0,...,2} {
                    \foreach \z in {0,...,2} {
                        \draw[gray,thin] (\x*2,\y*1.5) -- (\x*2+2,\z*1.5);
                    }
                }
            }
        \end{tikzpicture}
    };

    \node[above=0.1cm of nn] {Neural network};

    \node[box,right=of nn] (pred) {
        \begin{tikzpicture}[]
            \foreach \x/\y/\c in {0/0.2/red, 0.3/0.8/blue, 0.6/0.4/red, 0.8/0.9/blue, 0.2/0.5/red, 0.9/0.3/blue} {
                \fill[\c] (\x,\y) circle (0.1);
            }
            \draw[->] (0,0) -- (1,0);
            \draw[->] (0,0) -- (0,1);
        \end{tikzpicture}
    };

    \node[above=0.1cm of pred, text width=2cm, align=center] {Predicted labels};

    \node[box,right=of pred] (comppred) {
        \begin{tikzpicture}[]
            \fill[gray] (0.2,0.5) -- (0.3,0.8) -- (0.6,0.4) -- cycle;
            \fill[gray] (0.3,0.8) -- (0.8,0.9) -- (0.6,0.4) -- cycle;
            \draw[black,line width=0.3mm] (0.3,0.8) -- (0.8,0.9);
            \draw[black,line width=0.3mm] (0.6,0.4) -- (0.8,0.9);
            \draw[black,line width=0.3mm] (0.6,0.4) -- (0.3,0.8);
            \draw[black,line width=0.3mm] (0.6,0.4) -- (0.9,0.3);
            \draw[black,line width=0.3mm] (0.2,0.5) -- (0.6,0.4);
            \draw[black,line width=0.3mm] (0.2,0.5) -- (0.3,0.8);
            \foreach \x/\y/\c in {0/0.2/red, 0.3/0.8/blue, 0.6/0.4/red, 0.8/0.9/blue, 0.2/0.5/red, 0.9/0.3/blue} {
                \fill[\c] (\x,\y) circle (0.1);
            }
            \draw[->] (0,0) -- (1,0);
            \draw[->] (0,0) -- (0,1);
        \end{tikzpicture}
    };

    \node[above=0.1cm of comppred, text width=2cm, align=center] {Simplicial complex};

    \node[box,right=of comppred] (pd1) {
        \begin{tikzpicture}[]
            \draw[->] (0,0) -- (1,0) node[right] {birth};
            \draw[->] (0,0) -- (0,1) node[above] {death};
            \draw[dashed] (0,0) -- (1,1);
            \foreach \x/\y in {0.2/0.6, 0.4/0.8, 0.3/0.5} {
                \fill (\x,\y) circle (0.1);
            }
        \end{tikzpicture}
    };
    
    \node[above=0.1cm of pd1, text width=2cm, align=center] {Persistence diagram, $\dim = 1$};

    % Second column - Ground truth pipeline
    \node[box,below=1cm of pd1] (pd2) {
        \begin{tikzpicture}[]
            \draw[->] (0,0) -- (1,0) node[right] {birth};
            \draw[->] (0,0) -- (0,1) node[above] {death};
            \draw[dashed] (0,0) -- (1,1);
            \foreach \x/\y in {0.15/0.65, 0.45/0.85, 0.25/0.55} {
                \fill (\x,\y) circle (0.1);
            }
        \end{tikzpicture}
    };

    \node[box,left=1cm of pd2] (compgt) {
        \begin{tikzpicture}[]
            \fill[gray] (0.6,0.4) -- (0.8,0.9) -- (0.9,0.3) -- cycle;
            \fill[gray] (0.3,0.8) -- (0.8,0.9) -- (0.6,0.4) -- cycle;
            \draw[black,line width=0.3mm] (0.8,0.9) -- (0.9,0.3);
            \draw[black,line width=0.3mm] (0.6,0.4) -- (0.9,0.3);
            \draw[black,line width=0.3mm] (0.6,0.4) -- (0.8,0.9);
            \draw[black,line width=0.3mm] (0.3,0.8) -- (0.8,0.9);
            \draw[black,line width=0.3mm] (0.3,0.8) -- (0.6,0.4);
            \foreach \x/\y/\c in {0/0.2/red, 0.3/0.8/red, 0.6/0.4/red, 0.8/0.9/blue, 0.2/0.5/red, 0.9/0.3/blue} {
                \fill[\c] (\x,\y) circle (0.1);
            }
            \draw[->] (0,0) -- (1,0);
            \draw[->] (0,0) -- (0,1);
        \end{tikzpicture}
    };

    \node[below=0.1cm of compgt, text width=2cm, align=center] {Simplicial complex};

    \node[box,left=of compgt] (gt) {
        \begin{tikzpicture}[]
            \foreach \x/\y/\c in {0/0.2/red, 0.3/0.8/red, 0.6/0.4/red, 0.8/0.9/blue, 0.2/0.5/red, 0.9/0.3/blue} {
                \fill[\c] (\x,\y) circle (0.1);
            }
            \draw[->] (0,0) -- (1,0);
            \draw[->] (0,0) -- (0,1);
        \end{tikzpicture}
    };

    \node[below=0.1cm of gt, text width=2.5cm, align=center] {Ground truth labels};

    % Distance calculation
    \node[box,right=of pd1] (dist) {
        \begin{tikzpicture}[]
            \draw[->] (0,0) -- (1,0) node[right] {birth};
            \draw[->] (0,0) -- (0,1) node[above] {death};
            \draw[dashed] (0,0) -- (1,1);
            \foreach \x/\y in {0.2/0.6, 0.4/0.8, 0.3/0.5} {
                \fill[blue] (\x,\y) circle (0.1);
            }
            \foreach \x/\y in {0.15/0.65, 0.45/0.85, 0.25/0.55} {
                \fill[red] (\x,\y) circle (0.1);
            }
            \foreach \x/\y/\xx/\yy in {0.2/0.6/0.15/0.65, 0.4/0.8/0.45/0.85, 0.3/0.5/0.25/0.55} {
                \draw[gray,dotted] (\x,\y) -- (\xx,\yy);
            }
        \end{tikzpicture}
    };

    \node[above=0.1cm of dist] {Wasserstein distance};

    % Arrows
    \draw[arrow] (data1) -- (nn);
    \draw[arrow] (nn) -- (pred);
    \draw[arrow] (pred) -- (comppred);
    \draw[arrow] (comppred) -- (pd1);
    \draw[arrow] (gt) -- (compgt);
    \draw[arrow] (compgt) -- (pd2);
    \draw[arrow] (pd1) -- (dist);
    \draw[arrow] (pd2) -- (dist);

    \end{tikzpicture}
    }
\end{frame}


\begin{frame}{Input data}
    \begin{itemize}
        \item MNIST: 28x28 grayscale images of handwritten digits, $\dim = 784$
        \includegraphics[width=0.8\textwidth]{images/mnist.png}
        \item FashionMNIST: 28x28 grayscale images of fashion articles, $\dim = 784$
        \includegraphics[width=0.8\textwidth]{images/fashionmnist.png}
        \item CIFAR-10: 32x32 color images of 10 classes, $\dim = 3072$
        \includegraphics[width=0.8\textwidth]{images/cifar.png}
    \end{itemize}
\end{frame}

\begin{frame}{Pipeline}
    \resizebox{\textwidth}{!}{
    \begin{tikzpicture}[
        node distance=1cm,
        box/.style={rectangle,draw},
        arrow/.style={->,>=stealth,thick},
        every text node part/.style={font=\footnotesize}
    ]
    
    \node[box,right=of data1] (nn) {
        \begin{tikzpicture}[scale=0.25]
            \foreach \x in {0,...,3} {
                \foreach \y in {0,...,2} {
                    \fill (\x*2,\y*1.5) circle (0.2);
                }
            }
            \foreach \x in {0,...,2} {
                \foreach \y in {0,...,2} {
                    \foreach \z in {0,...,2} {
                        \draw[gray,thin] (\x*2,\y*1.5) -- (\x*2+2,\z*1.5);
                    }
                }
            }
        \end{tikzpicture}
    };

    \node[above=0.1cm of nn] {Neural network};

    \tikzset{
        every node/.style={
            opacity=0.4,
            execute at begin node={\ifx\tikz@fig@name\highlightednode\else\color{black!70}\fi}
        },
        every path/.style={opacity=0.4},
    }

    % First column - Prediction pipeline
    \node[box,name=data1] (data1) {
        \begin{tikzpicture}
            \foreach \x/\y in {0/0.2, 0.3/0.8, 0.6/0.4, 0.8/0.9, 0.2/0.5, 0.9/0.3} {
                \fill (\x,\y) circle (0.1);
            }
            \draw[->] (0,0) -- (1,0) node[right] {x};
            \draw[->] (0,0) -- (0,1) node[above] {y};
        \end{tikzpicture}
    };

    \node[above=0.1cm of data1] {Input data};

    \node[box,right=of nn] (pred) {
        \begin{tikzpicture}[]
            \foreach \x/\y/\c in {0/0.2/red, 0.3/0.8/blue, 0.6/0.4/red, 0.8/0.9/blue, 0.2/0.5/red, 0.9/0.3/blue} {
                \fill[\c] (\x,\y) circle (0.1);
            }
            \draw[->] (0,0) -- (1,0);
            \draw[->] (0,0) -- (0,1);
        \end{tikzpicture}
    };

    \node[above=0.1cm of pred, text width=2cm, align=center] {Predicted labels};

    \node[box,right=of pred] (comppred) {
        \begin{tikzpicture}[]
            \fill[gray] (0.2,0.5) -- (0.3,0.8) -- (0.6,0.4) -- cycle;
            \fill[gray] (0.3,0.8) -- (0.8,0.9) -- (0.6,0.4) -- cycle;
            \draw[black,line width=0.3mm] (0.3,0.8) -- (0.8,0.9);
            \draw[black,line width=0.3mm] (0.6,0.4) -- (0.8,0.9);
            \draw[black,line width=0.3mm] (0.6,0.4) -- (0.3,0.8);
            \draw[black,line width=0.3mm] (0.6,0.4) -- (0.9,0.3);
            \draw[black,line width=0.3mm] (0.2,0.5) -- (0.6,0.4);
            \draw[black,line width=0.3mm] (0.2,0.5) -- (0.3,0.8);
            \foreach \x/\y/\c in {0/0.2/red, 0.3/0.8/blue, 0.6/0.4/red, 0.8/0.9/blue, 0.2/0.5/red, 0.9/0.3/blue} {
                \fill[\c] (\x,\y) circle (0.1);
            }
            \draw[->] (0,0) -- (1,0);
            \draw[->] (0,0) -- (0,1);
        \end{tikzpicture}
    };

    \node[above=0.1cm of comppred, text width=2cm, align=center] {Simplicial complex};

    \node[box,right=of comppred] (pd1) {
        \begin{tikzpicture}[]
            \draw[->] (0,0) -- (1,0) node[right] {birth};
            \draw[->] (0,0) -- (0,1) node[above] {death};
            \draw[dashed] (0,0) -- (1,1);
            \foreach \x/\y in {0.2/0.6, 0.4/0.8, 0.3/0.5} {
                \fill (\x,\y) circle (0.1);
            }
        \end{tikzpicture}
    };
    
    \node[above=0.1cm of pd1, text width=2cm, align=center] {Persistence diagram, $\dim = 1$};

    % Second column - Ground truth pipeline
    \node[box,below=1cm of pd1] (pd2) {
        \begin{tikzpicture}[]
            \draw[->] (0,0) -- (1,0) node[right] {birth};
            \draw[->] (0,0) -- (0,1) node[above] {death};
            \draw[dashed] (0,0) -- (1,1);
            \foreach \x/\y in {0.15/0.65, 0.45/0.85, 0.25/0.55} {
                \fill (\x,\y) circle (0.1);
            }
        \end{tikzpicture}
    };

    \node[box,left=1cm of pd2] (compgt) {
        \begin{tikzpicture}[]
            \fill[gray] (0.6,0.4) -- (0.8,0.9) -- (0.9,0.3) -- cycle;
            \fill[gray] (0.3,0.8) -- (0.8,0.9) -- (0.6,0.4) -- cycle;
            \draw[black,line width=0.3mm] (0.8,0.9) -- (0.9,0.3);
            \draw[black,line width=0.3mm] (0.6,0.4) -- (0.9,0.3);
            \draw[black,line width=0.3mm] (0.6,0.4) -- (0.8,0.9);
            \draw[black,line width=0.3mm] (0.3,0.8) -- (0.8,0.9);
            \draw[black,line width=0.3mm] (0.3,0.8) -- (0.6,0.4);
            \foreach \x/\y/\c in {0/0.2/red, 0.3/0.8/red, 0.6/0.4/red, 0.8/0.9/blue, 0.2/0.5/red, 0.9/0.3/blue} {
                \fill[\c] (\x,\y) circle (0.1);
            }
            \draw[->] (0,0) -- (1,0);
            \draw[->] (0,0) -- (0,1);
        \end{tikzpicture}
    };

    \node[below=0.1cm of compgt, text width=2cm, align=center] {Simplicial complex};

    \node[box,left=of compgt] (gt) {
        \begin{tikzpicture}[]
            \foreach \x/\y/\c in {0/0.2/red, 0.3/0.8/red, 0.6/0.4/red, 0.8/0.9/blue, 0.2/0.5/red, 0.9/0.3/blue} {
                \fill[\c] (\x,\y) circle (0.1);
            }
            \draw[->] (0,0) -- (1,0);
            \draw[->] (0,0) -- (0,1);
        \end{tikzpicture}
    };

    \node[below=0.1cm of gt, text width=2.5cm, align=center] {Ground truth labels};

    % Distance calculation
    \node[box,right=of pd1] (dist) {
        \begin{tikzpicture}[]
            \draw[->] (0,0) -- (1,0) node[right] {birth};
            \draw[->] (0,0) -- (0,1) node[above] {death};
            \draw[dashed] (0,0) -- (1,1);
            \foreach \x/\y in {0.2/0.6, 0.4/0.8, 0.3/0.5} {
                \fill[blue] (\x,\y) circle (0.1);
            }
            \foreach \x/\y in {0.15/0.65, 0.45/0.85, 0.25/0.55} {
                \fill[red] (\x,\y) circle (0.1);
            }
            \foreach \x/\y/\xx/\yy in {0.2/0.6/0.15/0.65, 0.4/0.8/0.45/0.85, 0.3/0.5/0.25/0.55} {
                \draw[gray,dotted] (\x,\y) -- (\xx,\yy);
            }
        \end{tikzpicture}
    };

    \node[above=0.1cm of dist] {Wasserstein distance};

    % Arrows
    \draw[arrow] (data1) -- (nn);
    \draw[arrow] (nn) -- (pred);
    \draw[arrow] (pred) -- (comppred);
    \draw[arrow] (comppred) -- (pd1);
    \draw[arrow] (gt) -- (compgt);
    \draw[arrow] (compgt) -- (pd2);
    \draw[arrow] (pd1) -- (dist);
    \draw[arrow] (pd2) -- (dist);

    \end{tikzpicture}
    }
\end{frame}

% \begin{frame}{Models}
%     \only<1>{\vspace*{45pt}}
%     \begin{itemize}
%         \item Fully-connected neural network with ReLU activations

%         \only<1>{\hspace*{-1.5em}\begin{tikzpicture}[
%             node distance=1cm,
%             box/.style={rectangle,draw},
%             arrow/.style={->,>=stealth,thick},
%             every text node part/.style={font=\footnotesize}
%         ]
%             \node[box] (input) { \begin{tikzpicture}[
%                 neuron/.style={circle,draw,minimum size=0.5cm,fill=gray!50},
%             ]
%                 \node[neuron] (n0) at (0,2.4) {};
%                 \node[neuron] (n1) at (0,1.6) {};
%                 \node[neuron] (n2) at (0,0.8) {};
%                 \node[neuron] (n3) at (0,-0.8) {};
%                 \node[neuron] (n4) at (0,-1.6) {};
%                 \node at (0,0) {$\vdots$};
%             \end{tikzpicture} }
%             \node[below=0.1cm of input,text width=2cm,align=center] (inputlabel) {Input $\dim = 784$};

%             \node[box,right=of input] (l1) { \begin{tikzpicture}[
%                 neuron/.style={circle,draw,minimum size=0.5cm,fill=gray!50},
%             ]
%                 \node[neuron] (n1) at (0,1.6) {};
%                 \node[neuron] (n2) at (0,0.8) {};
%                 \node[neuron] (n3) at (0,-0.8) {};
%                 \node[neuron] (n4) at (0,-1.6) {};
%                 \node at (0,0) {$\vdots$};
%             \end{tikzpicture} }
%             \node[below=0.1cm of l1,text width=2cm,align=center] (l1label) {Layer 1 $\dim = 512$};

%             \node[box,right=0.5cm of l1] (relu1) { ReLU }

%             \node[box,right=of relu1] (l2) { \begin{tikzpicture}[
%                 neuron/.style={circle,draw,minimum size=0.5cm,fill=gray!50},
%             ]
%                 \node[neuron] (n1) at (0,1.6) {};
%                 \node[neuron] (n2) at (0,0.8) {};
%                 \node[neuron] (n3) at (0,-0.8) {};
%                 \node at (0,0) {$\vdots$};
%             \end{tikzpicture} }
%             \node[below=0.1cm of l2,text width=2cm,align=center] (l2label) {Layer 2 $\dim = 128$};

%             \node[box,right=0.5cm of l2] (relu2) { ReLU }

%             \node[box,right=of relu2] (l3) { \begin{tikzpicture}[
%                 neuron/.style={circle,draw,minimum size=0.5cm,fill=gray!50},
%             ]
%                 \node[neuron] (n2) at (0,0.8) {};
%                 \node[neuron] (n3) at (0,-0.8) {};
%                 \node at (0,0) {$\vdots$};
%             \end{tikzpicture} }
%             \node[below=0.1cm of l3,text width=2cm,align=center] (l2label) {Layer 3 $\dim = 16$};

%             \node[box,right=0.5cm of l3] (relu3) { ReLU }

%             \node[box,right=of relu3] (l4) { \begin{tikzpicture}[
%                 neuron/.style={circle,draw,minimum size=0.5cm,fill=gray!50},
%             ]
%                 \node[neuron] (n2) at (0,0.8) {};
%                 \node[neuron] (n3) at (0,-0.8) {};
%                 \node at (0,0) {$\vdots$};
%             \end{tikzpicture} }
%             \node[below=0.1cm of l4,text width=2cm,align=center] (l2label) {Output layer $\dim = 10$};

%             \draw[arrow] (input) -- (l1);
%             \draw[arrow] (l1) -- (relu1);
%             \draw[arrow] (relu1) -- (l2);
%             \draw[arrow] (l2) -- (relu2);
%             \draw[arrow] (relu2) -- (l3);
%             \draw[arrow] (l3) -- (relu3);
%             \draw[arrow] (relu3) -- (l4);
%         \end{tikzpicture}}
%         \item<2-> Convolutional NN from the PyTorch MNIST tutorial + modifications:
%         \begin{itemize}
%             \item Reduced layer sizes
%             \item Increased layer sizes
%             \item Additional layers
%             \item Aggressive learning rate growth ($\gamma = 1.9$) to simulate overfitting
%             \item Small learning rate $(\alpha = 10^{-6})$ to simulate underfitting
%         \end{itemize}
        
%         \resizebox{0.8\textwidth}{!}{ \includesvg[width=\textwidth]{nn.svg} }
%     \end{itemize}
% \end{frame}

% \begin{frame}{Simplicial complexes}
%     \begin{itemize}
%         \item \emph{Labeled \v{C}ech complex}:
%         \begin{itemize}
%             \item A modification of the standard \v{C}ech complex
%             \item Has statistical guarantees for decision boundary recovery, but is intractable
%             \item Not applicable to multi-class problems
%         \end{itemize}
%         \item \emph{Labeled Vietoris-Rips complex}:
%         \begin{itemize}
%             \item A modification of the standard Vietoris-Rips complex
%             \item No guarantees, but is tractable
%             \item Can be applied to multi-class problems \textcolor{gray}{(new!)}
%         \end{itemize}
%     \end{itemize}
% \end{frame}

% \begin{frame}{Labeled \v{C}ech complex}
%     \begin{columns}
%         \column{0.55\textwidth}
%         \begin{itemize}
%             \item Set of points $X$
%             \item Reference set of points $Y$
%             \item Parameters $\varepsilon$ and $\gamma$
%         \end{itemize}
%         \onslide<2->{
%         $L\check{C}_{X, Y}^{\varepsilon, \gamma}$ contains
%         \(x_0, \dots, x_n \in X\) iff:
%         \begin{enumerate}
%             \item<2-> For each \(i \in (0, \dots, n)\)
%             \(\exists y \in Y : \norm{x_i - y} \leq \gamma\).
%             \item<3-> \(\bigcap_{i = 0}^n B_\varepsilon(x_i) \neq \emptyset\)
%         \end{enumerate}
%         }
%         \onslide<4->{\begin{itemize}
%             \item Filtration is done by varying $\varepsilon$
%             \item Simplices are on one side of the boundary
%             \item Not applicable to multiple classes
%             \item Not tractable
%             \item Has probabilistic recovery guarantees
%         \end{itemize}
%         }
%         \column{0.55\textwidth}
%         \hspace*{-0.5cm}
%         \only<1>{\resizebox{1.1\textwidth}{!}{\input{plots/lc_points.pgf}}}
%         \only<2>{\resizebox{1.1\textwidth}{!}{\input{plots/lc_union.pgf}}}
%         \only<3->{\resizebox{1.1\textwidth}{!}{\input{plots/lc_full.pgf}}}
%     \end{columns}
% \end{frame}

\begin{frame}{Pipeline}
    \resizebox{\textwidth}{!}{
    \begin{tikzpicture}[
        node distance=1cm,
        box/.style={rectangle,draw},
        arrow/.style={->,>=stealth,thick},
        every text node part/.style={font=\footnotesize}
    ]

    \node[box,right=of pred] (comppred) {
        \begin{tikzpicture}[]
            \fill[gray] (0.2,0.5) -- (0.3,0.8) -- (0.6,0.4) -- cycle;
            \fill[gray] (0.3,0.8) -- (0.8,0.9) -- (0.6,0.4) -- cycle;
            \draw[black,line width=0.3mm] (0.3,0.8) -- (0.8,0.9);
            \draw[black,line width=0.3mm] (0.6,0.4) -- (0.8,0.9);
            \draw[black,line width=0.3mm] (0.6,0.4) -- (0.3,0.8);
            \draw[black,line width=0.3mm] (0.6,0.4) -- (0.9,0.3);
            \draw[black,line width=0.3mm] (0.2,0.5) -- (0.6,0.4);
            \draw[black,line width=0.3mm] (0.2,0.5) -- (0.3,0.8);
            \foreach \x/\y/\c in {0/0.2/red, 0.3/0.8/blue, 0.6/0.4/red, 0.8/0.9/blue, 0.2/0.5/red, 0.9/0.3/blue} {
                \fill[\c] (\x,\y) circle (0.1);
            }
            \draw[->] (0,0) -- (1,0);
            \draw[->] (0,0) -- (0,1);
        \end{tikzpicture}
    };

    \node[above=0.1cm of comppred, text width=2cm, align=center] {Simplicial complex};
    
    \node[box,left=1cm of pd2] (compgt) {
        \begin{tikzpicture}[]
            \fill[gray] (0.6,0.4) -- (0.8,0.9) -- (0.9,0.3) -- cycle;
            \fill[gray] (0.3,0.8) -- (0.8,0.9) -- (0.6,0.4) -- cycle;
            \draw[black,line width=0.3mm] (0.8,0.9) -- (0.9,0.3);
            \draw[black,line width=0.3mm] (0.6,0.4) -- (0.9,0.3);
            \draw[black,line width=0.3mm] (0.6,0.4) -- (0.8,0.9);
            \draw[black,line width=0.3mm] (0.3,0.8) -- (0.8,0.9);
            \draw[black,line width=0.3mm] (0.3,0.8) -- (0.6,0.4);
            \foreach \x/\y/\c in {0/0.2/red, 0.3/0.8/red, 0.6/0.4/red, 0.8/0.9/blue, 0.2/0.5/red, 0.9/0.3/blue} {
                \fill[\c] (\x,\y) circle (0.1);
            }
            \draw[->] (0,0) -- (1,0);
            \draw[->] (0,0) -- (0,1);
        \end{tikzpicture}
    };

    \node[below=0.1cm of compgt, text width=2cm, align=center] {Simplicial complex};

    \tikzset{
        every node/.style={
            opacity=0.4,
            execute at begin node={\ifx\tikz@fig@name\highlightednode\else\color{black!70}\fi}
        },
        every path/.style={opacity=0.4},
    }

    % First column - Prediction pipeline
    \node[box,name=data1] (data1) {
        \begin{tikzpicture}
            \foreach \x/\y in {0/0.2, 0.3/0.8, 0.6/0.4, 0.8/0.9, 0.2/0.5, 0.9/0.3} {
                \fill (\x,\y) circle (0.1);
            }
            \draw[->] (0,0) -- (1,0) node[right] {x};
            \draw[->] (0,0) -- (0,1) node[above] {y};
        \end{tikzpicture}
    };

    \node[above=0.1cm of data1] {Input data};

    \node[box,right=of data1] (nn) {
        \begin{tikzpicture}[scale=0.25]
            \foreach \x in {0,...,3} {
                \foreach \y in {0,...,2} {
                    \fill (\x*2,\y*1.5) circle (0.2);
                }
            }
            \foreach \x in {0,...,2} {
                \foreach \y in {0,...,2} {
                    \foreach \z in {0,...,2} {
                        \draw[gray,thin] (\x*2,\y*1.5) -- (\x*2+2,\z*1.5);
                    }
                }
            }
        \end{tikzpicture}
    };

    \node[above=0.1cm of nn] {Neural network};

    \node[box,right=of nn] (pred) {
        \begin{tikzpicture}[]
            \foreach \x/\y/\c in {0/0.2/red, 0.3/0.8/blue, 0.6/0.4/red, 0.8/0.9/blue, 0.2/0.5/red, 0.9/0.3/blue} {
                \fill[\c] (\x,\y) circle (0.1);
            }
            \draw[->] (0,0) -- (1,0);
            \draw[->] (0,0) -- (0,1);
        \end{tikzpicture}
    };

    \node[above=0.1cm of pred, text width=2cm, align=center] {Predicted labels};

    \node[box,right=of comppred] (pd1) {
        \begin{tikzpicture}[]
            \draw[->] (0,0) -- (1,0) node[right] {birth};
            \draw[->] (0,0) -- (0,1) node[above] {death};
            \draw[dashed] (0,0) -- (1,1);
            \foreach \x/\y in {0.2/0.6, 0.4/0.8, 0.3/0.5} {
                \fill (\x,\y) circle (0.1);
            }
        \end{tikzpicture}
    };
    
    \node[above=0.1cm of pd1, text width=2cm, align=center] {Persistence diagram, $\dim = 1$};

    % Second column - Ground truth pipeline
    \node[box,below=1cm of pd1] (pd2) {
        \begin{tikzpicture}[]
            \draw[->] (0,0) -- (1,0) node[right] {birth};
            \draw[->] (0,0) -- (0,1) node[above] {death};
            \draw[dashed] (0,0) -- (1,1);
            \foreach \x/\y in {0.15/0.65, 0.45/0.85, 0.25/0.55} {
                \fill (\x,\y) circle (0.1);
            }
        \end{tikzpicture}
    };

    \node[box,left=of compgt] (gt) {
        \begin{tikzpicture}[]
            \foreach \x/\y/\c in {0/0.2/red, 0.3/0.8/red, 0.6/0.4/red, 0.8/0.9/blue, 0.2/0.5/red, 0.9/0.3/blue} {
                \fill[\c] (\x,\y) circle (0.1);
            }
            \draw[->] (0,0) -- (1,0);
            \draw[->] (0,0) -- (0,1);
        \end{tikzpicture}
    };

    \node[below=0.1cm of gt, text width=2.5cm, align=center] {Ground truth labels};

    % Distance calculation
    \node[box,right=of pd1] (dist) {
        \begin{tikzpicture}[]
            \draw[->] (0,0) -- (1,0) node[right] {birth};
            \draw[->] (0,0) -- (0,1) node[above] {death};
            \draw[dashed] (0,0) -- (1,1);
            \foreach \x/\y in {0.2/0.6, 0.4/0.8, 0.3/0.5} {
                \fill[blue] (\x,\y) circle (0.1);
            }
            \foreach \x/\y in {0.15/0.65, 0.45/0.85, 0.25/0.55} {
                \fill[red] (\x,\y) circle (0.1);
            }
            \foreach \x/\y/\xx/\yy in {0.2/0.6/0.15/0.65, 0.4/0.8/0.45/0.85, 0.3/0.5/0.25/0.55} {
                \draw[gray,dotted] (\x,\y) -- (\xx,\yy);
            }
        \end{tikzpicture}
    };

    \node[above=0.1cm of dist] {Wasserstein distance};

    % Arrows
    \draw[arrow] (data1) -- (nn);
    \draw[arrow] (nn) -- (pred);
    \draw[arrow] (pred) -- (comppred);
    \draw[arrow] (comppred) -- (pd1);
    \draw[arrow] (gt) -- (compgt);
    \draw[arrow] (compgt) -- (pd2);
    \draw[arrow] (pd1) -- (dist);
    \draw[arrow] (pd2) -- (dist);

    \end{tikzpicture}
    }
\end{frame}



\begin{frame}{Labeled Vietoris-Rips complex}
    \begin{columns}
        \column{0.6\textwidth}
        \begin{itemize}
            \item Set of points $X$
            \item Labels $c: X \to \mathbb{Z}_k$
            \item Parameter \(\varepsilon\)
        \end{itemize}
        Constructed in three steps:
        \begin{enumerate}
            \item<2-> Create a graph \(G_\varepsilon\) with vertex set \(X\) by adding an edge 
            between points \(x_i, x_j \in X\) iff:
            \begin{itemize}
                \item \(\norm{x_i - x_j} \leq \varepsilon\) (points are close enough)
                \item \(c(x_i) \neq c(x_j)\) (different classes)
            \end{itemize}
            
            \item<3-> Add edges between all 2-hop neighbors in \(G_\varepsilon\)          
            \item<4-> Standard Vietoris-Rips construction: include simplex if all faces are included
        \end{enumerate}
        \only<5>{
            \begin{itemize}
                \item Simplices cross the boundary
                \item Applicable to multiple classes
            \end{itemize}
        }
        \column{0.4\textwidth}
        \hspace*{-0.5cm}
        \only<1>{\hspace*{-1em}\resizebox{1.2\textwidth}{!}{\input{plots/lvr_points.pgf}}}
        \only<2>{\hspace*{-1em}\resizebox{1.2\textwidth}{!}{\input{plots/lvr_step1.pgf}}}
        \only<3>{\hspace*{-1em}\resizebox{1.2\textwidth}{!}{\input{plots/lvr_step2.pgf}}}
        \only<4->{\hspace*{-1em}\resizebox{1.2\textwidth}{!}{\input{plots/lvr_step3.pgf}}}
    \end{columns}
\end{frame}

\begin{frame}{Synthetic 2D experiemnts}
    To see if the LVR complex recovers the homology of the decision boundary,
    we use synthetic 2D data with nested annuli.
    \begin{figure}
        \begin{subfigure}{0.3\textwidth}
            \includegraphics[width=\textwidth]{plots/nested.jpg}
        \end{subfigure}%
        \begin{subfigure}{0.3\textwidth}
            \resizebox{\textwidth}{!}{
                \input{plots/nested_ph.pgf}
            }
            % \caption{Persistence diagram}
        \end{subfigure}%
        \begin{subfigure}{0.3\textwidth}
            \includegraphics[width=\textwidth]{plots/nested_complex_9_no_cc.jpg}
            % \caption{Simplicial complex}
        \end{subfigure}
    \end{figure}
    Edges cross the decision boundary multiple times $ \implies $ spurious holes appear.
\end{frame}

\begin{frame}{Circumcircle filtering}
    \begin{itemize}
        \item Remove an edge $AB$ if exists vertex $C : |AB|^2 > (|AC|^2 + |BC|^2) \theta$.
        \item $\theta$ is a parameter to relax the condition.
    \end{itemize}
    \begin{center}
        \begin{tikzpicture}[scale=0.5]
            \coordinate (A) at (0,0);
            \coordinate (B) at (5,2);
            \coordinate (C) at (3.5,-1.5); 

            % circle center
            \coordinate (M) at ($(A)!0.5!(B)$);

            % triangle
            \draw[thick] (A) -- (B) -- (C) -- cycle;
            \draw ($(C)!0.1!(B)$) -- ($(C) + (-0.2,0.5)$) -- ($(C)!0.1!(A)$);

            % circle
            \pgfmathsetmacro{\radius}{sqrt((5)^2 + (2)^2)/2 * 0.5}
            \draw[fill=blue!50, fill opacity=0.3] (M) circle (\radius);
            \node[above] at ($(M) + (0.0,1.3)$) {$\theta = 1.3$};

            \node[left]  at (A) {$A$};
            \node[right] at (B) {$B$};
            \node[below] at (C) {$C$};
        \end{tikzpicture}
        \begin{tikzpicture}[scale=0.5]
            \coordinate (A) at (0,0);
            \coordinate (B) at (5,2);
            \coordinate (C) at (3.5,-1.5); 

            % circle center
            \coordinate (M) at ($(A)!0.5!(B)$);

            % triangle
            \draw[thick] (A) -- (B) -- (C) -- cycle;
            \draw ($(C)!0.1!(B)$) -- ($(C) + (-0.2,0.5)$) -- ($(C)!0.1!(A)$);

            % circle
            \pgfmathsetmacro{\radius}{sqrt((5)^2 + (2)^2)/2}
            \draw[fill=blue!50, fill opacity=0.3] (M) circle (\radius);
            \node[above] at ($(M) + (0.0,2.7)$) {$\theta = 1.0$};

            \node[left]  at (A) {$A$};
            \node[right] at (B) {$B$};
            \node[below] at (C) {$C$};
        \end{tikzpicture}
        \begin{tikzpicture}[scale=0.5]
            \coordinate (A) at (0,0);
            \coordinate (B) at (5,2);
            \coordinate (C) at (3.5,-1.5); 

            % circle center
            \coordinate (M) at ($(A)!0.5!(B)$);

            % triangle
            \draw[thick] (A) -- (B) -- (C) -- cycle;
            \draw ($(C)!0.1!(B)$) -- ($(C) + (-0.2,0.5)$) -- ($(C)!0.1!(A)$);

            % circle
            \pgfmathsetmacro{\radius}{sqrt((5)^2 + (2)^2)/2 * 1.5}
            \draw[fill=blue!50, fill opacity=0.3] (M) circle (\radius);
            \node[above] at ($(M) + (0.0,4.0)$) {$\theta = 0.7$};

            \node[left]  at (A) {$A$};
            \node[right] at (B) {$B$};
            \node[below] at (C) {$C$};
        \end{tikzpicture}
    \end{center}
\end{frame}

\begin{frame}{2D Validation}
    \begin{columns}
        % LEFT COLUMN: The Visual Result (Proof it works)
        \column{0.45\textwidth}
        \begin{figure}
            \centering
            % Top row: Before/After images
            \begin{subfigure}{0.48\textwidth}
                \includegraphics[width=\textwidth]{plots/nested_complex_9_no_cc.jpg}
                \caption*{\tiny Original}
            \end{subfigure}%
            \hfill
            \begin{subfigure}{0.48\textwidth}
                \includegraphics[width=\textwidth]{plots/nested_complex_9_cc.jpg}
                \caption*{\tiny With Filter}
            \end{subfigure}
            
            \vspace{0.2cm}
            
            % Bottom row: Persistence Diagram
            \begin{subfigure}{\textwidth}
                \centering
                \resizebox{0.6\textwidth}{!}{
                    \input{plots/nested_ph_cc.pgf}
                }
                \caption*{\tiny Persistence Diagram Cleanup}
            \end{subfigure}
        \end{figure}

        % RIGHT COLUMN: The Engineering (The "Hero" Part)
        \column{0.55\textwidth}
        \textbf{Computational Bottleneck:}
        \begin{itemize}
            \item Requires checking the condition for every edge against every other node.
            \item Python prototypes were prohibitively slow.
        \end{itemize}

        \vspace{0.3cm}
        
        \textbf{C++ Implementation:}
        \begin{itemize}
            \item C++ SIMD extension to handle the filtering.
            \item \textbf{Outcome:} Reduced filtering time to negligible overhead compared to complex construction.
            \item Enabled scaling the analysis to large, high-dimensional datasets.
        \end{itemize}
    \end{columns}
\end{frame}

\begin{frame}{Circumcircle filtering impact on high-dimensional data}
    \begin{columns}
        \column{0.4\textwidth}
        % \resizebox{\textwidth}{!}{
\begin{table}
    \centering
    \begin{tabular}{rcc}
        \toprule
        Dataset & Binary & Multiclass \\
        \hline
        MNIST & 7 & 4 \\
        FashionMNIST & 14 & 1 \\
        CIFAR10 & 7 & 0 \\
        \bottomrule
    \end{tabular}
    \caption*{Maximum differences in Wasserstein distance with and without CC.}
    \label{tab:cc_effect}
\end{table}
        % }
        \column{0.7\textwidth}
    \begin{figure}
        \begin{subfigure}{0.4\textwidth}
            \resizebox{\textwidth}{!}{
                \input{plots/cc_effect_ph1.pgf}
            }
        \end{subfigure}
        \begin{subfigure}{0.4\textwidth}
            \resizebox{\textwidth}{!}{
                \input{plots/cc_effect_ph2.pgf}
            }
        \end{subfigure}
        \caption*{The two persistence diagrams that differ the most when CC is applied.}
    \end{figure}
    \end{columns}
    The C++ optimization allowed us to rigorously test the projects hypothesis.\\ 
    \textbf{Conclusion:} In the studied high-dimensional cases, sparsity renders filtering unnecessary, validating the use of the standard LVR complex for these tasks.
\end{frame}

% \begin{frame}{Results: binary classification}
%     \begin{figure}
%         \centering
%         \begin{subfigure}{0.49\textwidth}
%             \resizebox{\textwidth}{!}{
%                 \input{plots/class01-baseline-tbl.pgf}
%             }
%         \end{subfigure}
%         \begin{subfigure}{0.49\textwidth}
%             \resizebox{\textwidth}{!}{
%                 \input{plots/class01-baseline-wass.pgf}
%             }
%         \end{subfigure}
%         \caption*{Evolution of topological metrics during training for the classes 0 and 1 in the MNIST dataset.}
%         \label{fig:baseline-topmetrics}
%     \end{figure}
% \end{frame}

% \begin{frame}{Results: binary classification}
%     \Wider[5em]{
%     \begin{figure}
%         \centering
%         \begin{subfigure}{0.24\textwidth}
%             \resizebox{\textwidth}{!}{
%                 \input{plots/nn1_class01_mnist_pd.pgf}
%             }
%             \caption{Epoch 1}
%         \end{subfigure}
%         \begin{subfigure}{0.24\textwidth}
%             \resizebox{\textwidth}{!}{
%                 \input{plots/nn7_class01_mnist_pd.pgf}
%             }
%             \caption{Epoch 7}
%         \end{subfigure}
%         \begin{subfigure}{0.24\textwidth}
%             \resizebox{\textwidth}{!}{
%                 \input{plots/nn14_class01_mnist_pd.pgf}
%             }
%             \caption{Epoch 14}
%         \end{subfigure}
%         \begin{subfigure}{0.24\textwidth}
%             \resizebox{\textwidth}{!}{
%                 \input{plots/gt_class01_mnist_pd.pgf}
%             }
%             \caption{Ground truth}
%         \end{subfigure}
%         \caption*{Evolution of persistence diagrams during training for the classes 0 and 1 in the MNIST dataset.}
%         \label{fig:baseline-pds}
%     \end{figure}
%     }
% \end{frame}


% \begin{frame}{Results: multiclass classification (MNIST)}
%     \Wider[5em]{
%     \begin{figure}
%         \begin{subfigure}{0.24\textwidth}
%             \resizebox{\textwidth}{!}{
%                 \input{plots/nn1_all_class_mnist_pd.pgf}
%             }
%             \caption{Epoch 1}
%         \end{subfigure}
%         \begin{subfigure}{0.24\textwidth}
%             \resizebox{\textwidth}{!}{
%                 \input{plots/nn7_all_class_mnist_pd.pgf}
%             }
%             \caption{Epoch 7}
%         \end{subfigure}
%         \begin{subfigure}{0.24\textwidth}
%             \resizebox{\textwidth}{!}{
%                 \input{plots/nn14_all_class_mnist_pd.pgf}
%             }
%             \caption{Epoch 14}
%         \end{subfigure}
%         \begin{subfigure}{0.24\textwidth}
%             \resizebox{\textwidth}{!}{
%                 \input{plots/gt_all_class_mnist_pd.pgf}
%             }
%             \caption{Ground truth}
%         \end{subfigure}
%         \caption*{Evolution of persistence diagrams in the multiclass setting.}
%         \label{fig:multiclass-pds}
%     \end{figure}
%     }
% \end{frame}

\begin{frame}{Results: multiclass classification}
    \begin{columns}
        \column{0.2\textwidth}
        Clear indication of overfit in the overfit model's trajectory
        \column{0.8\textwidth}
        \resizebox{\textwidth}{!}{
            \input{plots/aarhus/all-class-wass.pgf}
        }
    \end{columns}
\end{frame}

\begin{frame}{Results: multiclass classification, train data}
    \begin{columns}
        \column{0.2\textwidth}
        TDA on training data, accuracy on test data
        \column{0.8\textwidth}
        \resizebox{\textwidth}{!}{
            \input{plots/aarhus/all-class-train-wass.pgf}
        }
    \end{columns}
\end{frame}

\begin{frame}{Results: multiclass classification, CIFAR10, 2000 points}
    \begin{columns}
        \column{0.2\textwidth}
        Weak correlation as dimensionality of data increases,
        number of datapoints is unchanged
        \column{0.8\textwidth}
        \resizebox{\textwidth}{!}{
            \input{plots/aarhus/all-class-cifar-wass.pgf}
        }
    \end{columns}
\end{frame}

\begin{frame}{Results: multiclass classification, CIFAR10, 8000 points}
    \begin{columns}
        \column{0.2\textwidth}
        Increasing number of points improves correlation
        \column{0.8\textwidth}
        \resizebox{\textwidth}{!}{
            \input{plots/aarhus/all-class-cifar-p800-wass.pgf}
        }
    \end{columns}
\end{frame}

\begin{frame}{Conclusion}
    \begin{columns}
    \begin{column}{0.5\textwidth}
    \begin{itemize}
        % \item<1-> Multiclass LVR complex is better
        % \only<1>{
        %     \begin{itemize}
        %         \item Preserves more topological information
        %         \item Stronger correlation
        %         \item More computationally efficient
        %     \end{itemize}
        % }
        \item<1-> TDA provides insights into classifier behavior
        \only<1>{\begin{itemize}
            \item Strong correlation between Wasserstein distance and model accuracy
            \item Wasserstein distance increases during overfitting
        \end{itemize}}
        \item<2-> Training data decision boundary topology correlates with test performance
        \only<2>{\begin{itemize}
            \item A-priori indicator for model behavior
            \item Enables model evaluation without separate test sets
            \item Could serve as early overfitting detection
        \end{itemize}}
        \item<3-> Dimensionality scaling from CIFAR-10 experiments
        \only<3>{\begin{itemize}
            \item Initial effectiveness decrease in higher dimensions
            \item Performance restored by increasing sample size
            \item Limitation: too many points required for very high-dimensional $X$
        \end{itemize}}
    \end{itemize}
    \end{column}
    \begin{column}{0.5\textwidth}
        % \only<1>{\hspace*{-2em}\resizebox{1.1\textwidth}{!}{\input{plots/lvr_step3.pgf}}}
        \only<1>{\resizebox{\textwidth}{!}{\input{plots/aarhus/all-class-wass.pgf}}}
        \only<2>{\resizebox{\textwidth}{!}{\input{plots/aarhus/all-class-train-wass.pgf}}}
        \only<3>{\resizebox{\textwidth}{!}{\input{plots/aarhus/all-class-cifar-p800-wass.pgf}}}
    \end{column}
    \end{columns}
    % \only<5>{
    %     \vspace*{20pt}
    %     \centering
    %     \large Thank you for your attention!
    % }
\end{frame}

% \begin{frame}
%     \frametitle{Two-Column Itemized List with Image Overlays}

%     \begin{columns}
%         % First Column: Itemized List
%         \column{0.5\textwidth}
%         \begin{itemize}
%             \item<1-> First Item
%             \item<2-> Second Item
%             \item<3-> Third Item
%             \begin{itemize}
%                 \item<3-> Subitem A
%                 \item<3-> Subitem B
%             \end{itemize}
%             \item<4-> Fourth Item
%             \begin{itemize}
%                 \item<4-> Subitem C
%                 \item<4-> Subitem D
%             \end{itemize}
%         \end{itemize}

%         % Second Column: Images
%         \column{0.5\textwidth}
%         \only<1>{\includegraphics[width=\linewidth]{image1.jpg}}
%         \only<2>{\includegraphics[width=\linewidth]{image2.jpg}}
%         \only<3>{\includegraphics[width=\linewidth]{image3.jpg}}
%         \only<4>{\includegraphics[width=\linewidth]{image4.jpg}}
%     \end{columns}

% \end{frame}

\begin{frame}{Research Identity}
    My research interest lies consistently at the intersection of
    \textbf{computational systems} and \textbf{physical reality}.
    
    \vspace{0.5cm}
    
    \begin{columns}[t]
        \column{0.33\textwidth}
        \textbf{Robotics (ITMO)}
        \begin{itemize}
            \item \emph{Context:} Autonomous agents with strict compute limits.
            \item \emph{Challenge:} ML inference under extreme resource constraints.
        \end{itemize}
        
        \column{0.33\textwidth}
        \textbf{Satellite Nav (Bosch)}
        \begin{itemize}
            \item \emph{Context:} Global positioning systems with noisy signal data.
            \item \emph{Challenge:} Robust processing of noisy and partially observable signals.
        \end{itemize}
        
        \column{0.33\textwidth}
        \textbf{Topology (ETHZ)}
        \begin{itemize}
            \item \emph{Context:} High-dimensional geometric data analysis.
            \item \emph{Challenge:} Highly-efficient C++ kernels for high-dimensional geometric predicates.
        \end{itemize}
    \end{columns}

    \vspace{0.5cm}
    
    \begin{center}
        \textit{Common Thread: Understanding how domain-specific constraints shape computational models.}
    \end{center}
\end{frame}

\begin{frame}{Motivation: Why SimuCell3D?}
    \textbf{The Challenge:}
    \begin{itemize}
        \item Biology is the ultimate ``physical system"---massive scale, complex geometry, and noise.
        \item \emph{SimuCell3D} provides a strong framework for tissue simulation, but exploring new biological regimes at tissue scale poses modelling challenges.
    \end{itemize}

    \vspace{0.3cm}

    I want to apply my background in research and C++ engineering to:
    \begin{enumerate}
        \item \textbf{Extend Capabilities:} Implement the Reaction-Diffusion solvers (PDEs) required for chemical concentration awareness.
        \item \textbf{Scale Performance:} Optimize the core mechanics (collision/solvers) to run larger simulations faster.
        \item \textbf{Scientific Enablement:} Expand the range of biological questions that can be addressed through simulation.
    \end{enumerate}
\end{frame}

\begin{frame}
    Extra slides
\end{frame}

\begin{frame}{Binarization}
    \begin{columns}
        \column{0.8\textwidth}
        Previous work only considered binary classification by splitting
        a dataset with $n$ classes into $\binom{n}{2}$ binary datasets.
        This changes the homology groups:
        \begin{itemize}
            \item Original has $H_1 \not\cong 0$
            \item All binary decompositions have $H_1 \cong 0$
            % \item Original has $\dim H_0 = 1$
            % \item The red-green binary decomposition has $\dim H_0 = 2$.
        \end{itemize}
        It is better to avoid binarization.
        \column{0.2\textwidth}
        \begin{tikzpicture}
            \fill[blue] (0,0) circle(0.5);
    
            \fill[red]
            (0,-0.5)           % Start at bottom inner point
            arc(-90:90:0.5)     % Inner arc: radius=0.5 from -90Â° to 90Â° (bottom to top on the right side)
            -- (0,1)            % Line from top inner (0,0.5) to top outer (0,1)
            arc(90:-90:1)       % Outer arc: radius=1 from 90Â° to -90Â° (top to bottom on the right side)
            -- cycle;           

            \begin{scope}[rotate=180]
            \fill[green]
            (0,-0.5)
            arc(-90:90:0.5)
            -- (0,1)
            arc(90:-90:1)
            -- cycle;
            \end{scope}
            
            % Decision boundary
            \draw[line width=0.5mm] (0, 0.5) -- (0, 1);
            \draw[line width=0.5mm] (0, -0.5) -- (0, -1);
            \draw[line width=0.5mm] (0,0) circle (0.5);
        \end{tikzpicture}
        \linebreak

        \begin{tikzpicture}
            \fill[red]
            (0,-0.5)           % Start at bottom inner point
            arc(-90:90:0.5)     % Inner arc: radius=0.5 from -90Â° to 90Â° (bottom to top on the right side)
            -- (0,1)            % Line from top inner (0,0.5) to top outer (0,1)
            arc(90:-90:1)       % Outer arc: radius=1 from 90Â° to -90Â° (top to bottom on the right side)
            -- cycle;           

            \begin{scope}[rotate=180]
            \fill[green]
            (0,-0.5)
            arc(-90:90:0.5)
            -- (0,1)
            arc(90:-90:1)
            -- cycle;
            \end{scope}
            
            % Decision boundary
            \draw[line width=0.5mm] (0, 0.5) -- (0, 1);
            \draw[line width=0.5mm] (0, -0.5) -- (0, -1);
        \end{tikzpicture}
        \\

        \begin{tikzpicture}
            \fill[blue] (0,0) circle(0.5);
    
            \begin{scope}[rotate=180]
            \fill[green]
            (0,-0.5)
            arc(-90:90:0.5)
            -- (0,1)
            arc(90:-90:1)
            -- cycle;
            \end{scope}
            
            % Decision boundary
            \draw[line width=0.5mm] (0,0.5) arc (90:270:0.5);
        \end{tikzpicture}
    \end{columns}
\end{frame}

\begin{frame}{Results: binary classification}
    \begin{figure}
        \centering
        \resizebox{0.7\textwidth}{!}{
            \input{plots/aarhus/baseline-wass.pgf}
        }
        \caption*{Relationship between Wasserstein distance and model accuracy across
        all binary classification pairs in MNIST. Connected points represent consecutive
        epochs for the same class pair.}
        \label{fig:baseline-binary-scatter-wass}
    \end{figure}
\end{frame}

\begin{frame}[b]{Theoretical background: Machine learning}
    \begin{itemize}
        \item Learn from data without explicit programming
        \item<2-> Classifiers map input data $\in \mathbb{R}^d$ to class labels $\in \{1, \dots, n\}$
        \item<3-> Networks are a sequence of layers, data flowing from input layer to output layer
        \item<4-> To train, compute the gradient of the loss function with respect to the network parameters using \only<4>{\textcolor{red}{backpropagation}}\only<5->{backpropagation}, and update parameters using gradient descent
        \only<5-6>{\item Fully-connected layers: $y = A x + b$}
        \only<6>{\item Activation layers: nonlinearity for expressiveness}
        \item<7-> Convolutional layers: parameter-efficient filters for images / time series
    \end{itemize}
    \only<1>{\vspace*{113pt}}
    \only<2>{\vspace*{82pt}}
    \only<3>{\vspace*{77pt}}
    \only<4>{\vspace*{77pt}}
    \only<5>{\vspace*{63.5pt}}
    \only<6>{\vspace*{46pt}}
    \only<2>{
        \begin{tikzpicture}[
            node distance=1cm,
            box/.style={rectangle,draw},
            arrow/.style={->,>=stealth,thick},
            every text node part/.style={font=\footnotesize}
        ]
        
        \node[box] (input) { $x \in \mathbb{R}^d$ };
        
        \node[box,right=of input,text width=7cm,align=center] (nn) { Neural network };

        \node[box,right=of nn] (output) { Output $\in \{1, \dots, n\}$ };
        
        \draw[arrow] (input) -- (nn);
        \draw[arrow] (nn) -- (output);
        
        \end{tikzpicture}
    }
    \only<3>{
        \begin{tikzpicture}[
            node distance=1cm,
            box/.style={rectangle,draw},
            arrow/.style={->,>=stealth,thick},
            every text node part/.style={font=\footnotesize}
        ]
        
        \node[box] (input) { $x \in \mathbb{R}^d$ };

        \node[box,right=of input,text width=7cm,align=center] (nn) { \begin{tikzpicture}
            \node[box] (layer1) { Layer 1 };
            \node[box,right=of layer1] (layer2) { Layer 2 };
            \node[box,right=of layer2] (layer3) { Layer 3 };
            \node[right=of layer3] (layer4) {};
            \draw[arrow] (layer1) -- (layer2);
            \draw[arrow] (layer2) -- (layer3);
            \draw[arrow] (layer3) -- (layer4);
        \end{tikzpicture} };

        \node[box,right=of nn] (output) { Output $\in \{1, \dots, n\}$ };
        
        \draw[arrow] (input) -- (nn);
        \draw[arrow] (nn) -- (output);
        
        \end{tikzpicture}
    }
    \only<4>{
        \begin{tikzpicture}[
            node distance=1cm,
            box/.style={rectangle,draw},
            arrow/.style={->,>=stealth,thick},
            every text node part/.style={font=\footnotesize}
        ]
        
        \node[box] (input) { $x \in \mathbb{R}^d$ };

        \node[box,right=of input,text width=7cm,align=center] (nn) { \begin{tikzpicture}
            \node[box] (layer1) { Layer 1 };
            \node[box,right=of layer1] (layer2) { Layer 2 };
            \node[box,right=of layer2] (layer3) { Layer 3 };
            \node[right=of layer3] (layer4) {};
            \draw[arrow] (layer1) -- (layer2);
            \draw[arrow] (layer2) -- (layer3);
            \draw[arrow] (layer3) -- (layer4);
            \begin{scope}[transform canvas={yshift=-.4em}]
                \draw[arrow,red] (layer4) -- (layer3);
                \draw[arrow,red] (layer3) -- (layer2);
                \draw[arrow,red] (layer2) -- (layer1);
            \end{scope}
        \end{tikzpicture} };

        \node[box,right=of nn] (output) { Output $\in \{1, \dots, n\}$ };
        
        \draw[arrow] (input) -- (nn);
        \draw[arrow] (nn) -- (output);
        
        \begin{scope}[transform canvas={yshift=-.4em}]
            \draw[arrow,red] (output) -- (nn);
            \draw[arrow,red] (nn) -- (input);
        \end{scope}

        \end{tikzpicture}
    }
    \only<5>{
        \begin{tikzpicture}[
            node distance=1cm,
            box/.style={rectangle,draw},
            arrow/.style={->,>=stealth,thick},
            every text node part/.style={font=\footnotesize}
        ]
        
        \node[box] (input) { $x \in \mathbb{R}^d$ };

        \node[box,right=of input,text width=7cm,align=center] (nn) { \begin{tikzpicture}
            \node[box] (layer1) { $A_1x + b_1$ };
            \node[box,right=2.9em of layer1] (layer2) { Layer 2 };
            \node[box,right=2.9em of layer2] (layer3) { Layer 3 };
            \node[    right=2.9em of layer3] (layer4) {};
            \draw[arrow] (layer1) -- (layer2);
            \draw[arrow] (layer2) -- (layer3);
            \draw[arrow] (layer3) -- (layer4);
        \end{tikzpicture} };

        \node[box,right=of nn] (output) { Output $\in \{1, \dots, n\}$ };
        
        \draw[arrow] (input) -- (nn);
        \draw[arrow] (nn) -- (output);
        
        \end{tikzpicture}
    }
    \only<6>{
        \begin{tikzpicture}[
            node distance=1cm,
            box/.style={rectangle,draw},
            arrow/.style={->,>=stealth,thick},
            every text node part/.style={font=\footnotesize}
        ]
        
        \node[box] (input) { $x \in \mathbb{R}^d$ };

        \node[box,right=of input,text width=7cm,align=center] (nn) { \begin{tikzpicture}
            \node[box] (layer1) { $A_1x + b_1$ };
            \node[box,right=1.8em of layer1] (layer2) { $\tanh(A_1x + b_1)$ };
            \node[box,right=1.8em of layer2] (layer3) { Layer 3 };
            \node[    right=1.8em of layer3] (layer4) {};
            \draw[arrow] (layer1) -- (layer2);
            \draw[arrow] (layer2) -- (layer3);
            \draw[arrow] (layer3) -- (layer4);
        \end{tikzpicture} };

        \node[box,right=of nn] (output) { Output $\in \{1, \dots, n\}$ };
        
        \draw[arrow] (input) -- (nn);
        \draw[arrow] (nn) -- (output);
        
        \end{tikzpicture}
    }
    \only<7>{
        \includegraphics[width=0.6\textwidth]{conv.png}
    }
    \only<5-6>{\vspace*{10pt}}
\end{frame}

\end{document}